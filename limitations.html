<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C++ Insights: C++ Insights Limitations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"  class="clearfix"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
    <a href="index.html">
        <div class="title-and-logo">
            <div id="logo"><img alt="C++ Insights Logo" src="logo.png"/></div>
        </div>
    </a>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">C++ Insights Limitations</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>While the goal is to produce valid and correct code, in some instances, this is not possible. The two main reasons are:</p>
<ul>
<li>because the compiler can do things we users can't.</li>
<li>because the correct way is hard to implement.</li>
</ul>
<p>This page documents known limitations where the resulting transformation is inaccurate in terms of the standard.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Templates</h1>
<h2><a class="anchor" id="autotoc_md15"></a>
Point of instantiation of templates</h2>
<p>As <a target="_blank" href="https://github.com/andreasfertig/cppinsights/issues/472">#472</a> notes correctly, the point of instantiation of templates is not at the precise location as the standard describes it in <a target="_blank" href="https://eel.is/c++draft/temp.point">temp.point</a>.</p>
<p>The implementation in C++ Insights is that all implicit instantiations are placed directly after the primary template. This is the easiest way implementation-wise. The standard requires that such an instantiation is placed after the namespace declaration of the POI. Implementing this in C++ Insights would require knowledge about the line where a template was instantiated and the end of its enclosing namespace. While technically, this information is present in the form of <code>SourceLocation</code>, the traversal of the AST, and the straightforward text-dumping of the nodes does not allow sorting at this point.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Constant expressions as NTTPs</h2>
<p>As <a target="_blank" href="https://github.com/andreasfertig/cppinsights/issues/415">#415</a> notes, there are cases where C++ Insights is unable to show all the implicit conversions. The reason seems to be that Clang folds away expressions that cannot be recovered. See <a target="_blank" href="https://discourse.llvm.org/t/how-to-find-the-ast-node-for-conversion-operator-for-a-nttp/62507/3">discourse.llvm.org/t/how-to-find-the-ast-node-for-conversion-operator-for-a-nttp</a>.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Lambdas with static invoker</h1>
<h2><a class="anchor" id="autotoc_md18"></a>
Captureless lambdas</h2>
<p>Issue <a target="_blank" href="https://github.com/andreasfertig/cppinsights/issues/467">#467</a> raised awareness that captureless lambdas are more complicated. According to [expr.prim.lambda.closure] p7, the closure type has a conversion to a function pointer function:</p>
<blockquote class="doxtable">
<p>&zwj;The value returned by this conversion function is the address of a function F that, when invoked, has the same effect as invoking the closure typeâ€™s function call operator on a default-constructed instance of the closure type. F is a constexpr function if the function call operator is a constexpr function and is an immediate function if the function call operator is an immediate function. </p>
</blockquote>
<p>The code in #467 demonstrates a way to observe that C++ Insights generates less efficient code. Initially, the body of the call operator was replicated into the invoke function. However, a captureless lambda with a local <code>static</code> variable leads to different results. The latest version forwards the call from the invoke function to the call operator. This is still less optimal as the compiler does it. Even with <code>move</code> and <code>forward</code>, we get copies of non-moveable members in a parameter. At the same time, the compiler seems to be able to directly forward the invoke call to the call operator.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Lambda captures initialization</h2>
<p>C++ Insights shows a constructor for a lambda when it has captures. The compiler does better. It doesn't need a constructor, it can direct-initialize the members, and by that, the compiler reduces potential copies as they will happen with the C++ Insights version. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a target="_blank" href="http://www.doxygen.org/index.html"></a> 1.9.8
</small></address>
</body>
</html>
